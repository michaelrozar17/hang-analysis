#!/usr/bin/perl
###########################################################################
# Name:
#  hanalyzer.pl
#
# Description:
#  Perl script to read hang-analysis trace file (generated by Oracle database 
#	during hung situation) and render output in a tabular format
#
# Notes:
#  ./hanalyzer.pl --help to get help menu
#  Email pepymike17@gmail.com for suggestions/issues etc
#
###########################################################################
use strict;
use Getopt::Long;

my @data;
my $x=-1;
my $y=0;
my ($row,$col,$arg_count,$is_csv);
my ($ts,$sec)=(0,0);
my $tiw_flag=0;
my $pid;
my $call_stack;
my %waitevent_hist;
my $csv=",";
my $display_cnt= 15 - 1;

$arg_count = scalar @ARGV;
my $in_file = $ARGV[0];
#print "arg count =$arg_count\n";
usage() unless $arg_count < 4;
if ($arg_count == 0){
	print "Required hang-analysis trace file to read\n";
	usage();
}	

GetOptions(
	'tracefile=s' => \$in_file, '<>' => \&usage,
	'help' => \&usage,
	'csv' => \$is_csv,
	'display:i' => \$display_cnt
) or die "Invalid options passed. Try $0 --help\n";

sub usage{
	print "usage: $0 --tracefile=/path/to/hang-analysis.trc\n";
	print "option(s):\n\t--tracefile: supply the input hang-analysis or diag trace file containing hang-analysis\n";
	print "\t--csv: to generate a csv format output(optional)\n";
	print "\t--display: controls no. of records to be displayed in output, default 15(optional)\n";
	exit;
}

if ($is_csv){
	$csv=",";
}	
else{
	$csv="|";
}

print "Reading file $in_file\n";

# get the minutes value and convert to seconds
sub to_seconds {
	(my $lst) = @_; # getting array data in list context
	if ($lst =~ /([0-9]+) min (.*) sec/){
		($1*60) + $2;
	}
	elsif ($lst =~ /(.*) sec/){
		$1;
	}
}

open MYFILE,"<",$in_file  or die "Error opening diag trace file $in_file: $!\n";

while (<MYFILE>){
	if (/  instance: ([0-9]+)/){
		#chomp;
		$x++;
		$y=0;
		$data[$x][$y]=$1; #0
		next;
	}	
	
	if (/^  *os id: ([0-9]*)/){
		$data[$x][++$y]=$1 || 'NULL'; #1
	}
	if (/^  *process id: ([0-9]+)/){
		$data[$x][++$y]=$1; #2
		$pid=$1;
	}
	if (/^  *session id: ([0-9]+)/){
		$data[$x][++$y]=$1; #3
	}
	if (/session serial #: ([0-9]+)/){
		$data[$x][++$y]=$1; #4
	}
	if (/is waiting for '([^']+)/){
		$data[$x][++$y]=$1; #5
		$tiw_flag=1;#print "Twi flag is set for pid $pid\n";
	}
	elsif (/is not in a wait/){
		$data[$x][++$y]="Not in Wait"; #5
		$tiw_flag=2;
	}
	if ($tiw_flag == 1 && /^  *time in wait: (.* sec)/){
		$sec=&to_seconds($1);
		$data[$x][++$y]=$sec || 0; #6
		$tiw_flag=0;
		$data[$x][++$y]=0; #dummy increament to put "last wait" in column 7
	}
	elsif ($tiw_flag == 2){
		$data[$x][++$y]=0; #6
		$tiw_flag=0;
	}
	if (/last wait: ([0-9].*)/){
		$data[$x][++$y]=&to_seconds($1); #7
	}
	if (/blocking: ([0-9]+)/){
        $data[$x][++$y]=$1; #8
    }
	if (/current sql: (.{1,30})/ || /current sql:  */){ #sometimes sql text is available in next line hence null need to be matched
		$data[$x][++$y]=$1; #9
	}
	if (/short stack: (.*)/){
		$call_stack=$1; #10
		($data[$x][++$y]= $call_stack)  =~ s/[(<>][^A-Za-z]+/ /g;
	}

	if (/  event: '([^']+)/){ #patter with initial space before keyword event helped to avoid error: Modification of non-creatable array value attempted
		#because event matched following however 2nd and 3rd line are expected to match
		#      wait event: 'PX Deq Credit: send blkd'
		#              1.       event: 'PX Deq: reap credit'
		#              2.       event: 'PX Deq Credit: send blkd'
		if (/[Ii]dle/){
			next;
		}
		else{
			$waitevent_hist{$1}++;		
			if (!$data[$x][11]){
				$data[$x][11]=$1;
			}
			else{
				$data[$x][11]="$1 $data[$x][11]"; 
			}
		}
	}

	if (/and is blocked by .(.*)..$/){
		$data[$x][12]=$1;
	}

}


my @sorted_data = sort {$b->[8] <=> $a->[8]} @data;

print "\nSort by Max no. of Blocking Sessions\n";
print "~" x length("Sort by Max no. of Blocking Sessions") . "\n";

my $print_format=sprintf("%4s$csv %8s$csv %10s$csv %10s$csv %9s$csv %-30s$csv %-15s$csv %-17s$csv %-30s$csv %-10s\n","Inst","OS_ID","ProcessID","SessionID","SerialID","WaitingOn","TimeInWait(sec)","Blocking_Sess_Cnt","Current_SQL","BlockedBy");

print "$print_format";
print "-" x length($print_format) . "\n";

my $c=0;
my $print_line;
foreach $row (@sorted_data){
	$$row[9]='NULL' if (!$$row[9]);
	next if ($$row[5] =~ /idle/);
    $$row[12]='NULL' if (!$$row[12]);	
	printf "%4s$csv %8s$csv %10s$csv %10s$csv %9s$csv %-30s$csv %15s$csv %17s$csv %-30s$csv %-15s\n",$$row[0],$$row[1],$$row[2],$$row[3],$$row[4],$$row[5],$$row[6],$$row[8],$$row[9],$$row[12];
	last if ++$c > $display_cnt ;
}

print "\nContinuing with Stack information..\n\n";
$c=0;
foreach $row (@sorted_data){
	$$row[10]=' NULL' if (!$$row[10]);
	next if ($$row[5] =~ /idle/);
	printf "%4s$csv %8s$csv %10s$csv %10s$csv %-80s$csv (%20s)\n",$$row[0],$$row[1],$$row[2],$$row[3],$$row[10],$$row[11]; 
	last if ++$c > $display_cnt;
}

print "\n\nSort by Max Time in Wait\n";
print "~" x length("Sort by Max Time in Wait") . "\n";
$c=0;
print "$print_format";
print "-" x length($print_format) . "\n";

@sorted_data = sort {$b->[6] <=> $a->[6]} @data;
foreach $row (@sorted_data){
	$$row[9]='NULL' if (!$$row[9]);
	next if ($$row[5] =~ /idle/);
	$$row[12]='NULL' if (!$$row[12]);
    printf "%4s$csv %8s$csv %10s$csv %10s$csv %9s$csv %-30s$csv %15s$csv %17s$csv %-15s$csv %-15s\n",$$row[0],$$row[1],$$row[2],$$row[3],$$row[4],$$row[5],$$row[6],$$row[8],$$row[9],$$row[12];
	last if ++$c > $display_cnt;
}	

print "\nContinuing with Stack information..\n\n";
$c=0;
foreach $row (@sorted_data){
	$$row[10]=' NULL' if (!$$row[10]);
    next if ($$row[5] =~ /idle/);
	printf "%4s$csv %8s$csv %10s$csv %10s$csv %-80s$csv (%20s)\n",$$row[0],$$row[1],$$row[2],$$row[3],$$row[10],$$row[11];
    last if ++$c > $display_cnt;
}

print "\n\nSort by Max Running time and Not in Wait (spinning on CPU or hung)\n";
print "~" x length("Sort by Max Runing time and Not in Wait") . "\n";


printf "%4s$csv %8s$csv %10s$csv %10s$csv %9s$csv %-30s$csv %15s$csv %17s$csv %-15s\n","Inst","OS_ID","ProcessID","SessionID","SerialID","WaitingOn","RunningFor(sec)","Blocking_Sess_Cnt","Current_SQL";
print "-" x length("Inst|    OS_ID|  ProcessID|  SessionID|  SerialID| WaitingOn                     | RunningFor(sec)| Blocking_Sess_Cnt| Current_SQL               ") . "\n";
@sorted_data = sort {$b->[7] <=> $a->[7]} @data;
$c=0;
foreach $row (@sorted_data){
	$$row[9]='NULL' if (!$$row[9]);
	if ($$row[5] eq 'Not in Wait'){
	    printf "%4s$csv %8s$csv %10s$csv %10s$csv %9s$csv %-30s$csv %15s$csv %17s$csv %-15s\n",$$row[0],$$row[1],$$row[2],$$row[3],$$row[4],$$row[5],$$row[7],$$row[8],$$row[9];
	}
	last if ++$c > $display_cnt;
}

print "\nContinuing with Stack information..\n\n";
$c=0;
foreach $row (@sorted_data){
	$$row[11]=' NULL' if (!$$row[11]);
	if ($$row[5] eq 'Not in Wait'){
		printf "%4s$csv %8s$csv %10s$csv %10s$csv %-80s$csv (%20s)\n",$$row[0],$$row[1],$$row[2],$$row[3],$$row[10],$$row[11];
	}
	last if ++$c > $display_cnt;
}

print "\nTop WaitEvents History Count\n";
print "~" x length("Top WaitEvents History Count") . "\n";
$c=0;
foreach my $waitevent (sort {$waitevent_hist{$b} <=> $waitevent_hist{$a}} keys %waitevent_hist ){
	printf "%-35s$csv %5s\n", $waitevent, $waitevent_hist{$waitevent};
	last if ++$c > $display_cnt;
}
